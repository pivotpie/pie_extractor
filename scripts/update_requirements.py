#!/usr/bin/env python3
"""
Update and manage project dependencies.

This script helps maintain the project's requirements files:
- requirements.txt: Core production dependencies
- requirements-dev.txt: Development dependencies

Usage:
    python scripts/update_requirements.py [--dev] [--freeze]

Options:
    --dev    Update development requirements
    --freeze Freeze all dependencies to current versions
"""

import argparse
import datetime
import re
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Project root directory
PROJECT_ROOT = Path(__file__).parent.parent
REQUIREMENTS_DIR = PROJECT_ROOT / "requirements"
REQUIREMENTS_TXT = PROJECT_ROOT / "requirements.txt"
REQUIREMENTS_DEV_TXT = PROJECT_ROOT / "requirements-dev.txt"

# Header template for requirements files
HEADER = """# {title}
# This file is automatically generated. Do not edit it manually.
# Last updated: {date}

"""

def get_installed_packages() -> Dict[str, str]:
    """Get installed packages and their versions."""
    result = subprocess.run(
        [sys.executable, "-m", "pip", "freeze"],
        capture_output=True,
        text=True,
        check=True
    )
    
    packages = {}
    for line in result.stdout.strip().split('\n'):
        if '==' in line:
            name, version = line.split('==', 1)
            packages[name.lower()] = version.strip()
    
    return packages

def parse_requirements(file_path: Path) -> Tuple[Dict[str, str], List[str]]:
    """Parse requirements file into a dictionary of packages and comments."""
    packages = {}
    comments = []
    
    if not file_path.exists():
        return packages, comments
    
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                if line.strip('#'):  # Only add non-empty comments
                    comments.append(line)
                continue
            
            # Handle different requirement formats
            if '>=' in line:
                name, version = line.split('>=', 1)
                packages[name.strip().lower()] = f'>={version.strip()}'
            elif '==' in line:
                name, version = line.split('==', 1)
                packages[name.strip().lower()] = f'=={version.strip()}'
            else:
                packages[line.lower()] = ''
    
    return packages, comments

def write_requirements(
    file_path: Path,
    packages: Dict[str, str],
    comments: List[str],
    title: str
) -> None:
    """Write requirements to a file with proper formatting."""
    # Sort packages case-insensitively
    sorted_packages = sorted(packages.items(), key=lambda x: x[0].lower())
    
    with open(file_path, 'w', encoding='utf-8') as f:
        # Write header
        f.write(HEADER.format(
            title=title,
            date=datetime.datetime.now().strftime('%Y-%m-%d')
        ))
        
        # Write comments
        if comments:
            f.write('\n'.join(comments) + '\n\n')
        
        # Write packages
        for name, version in sorted_packages:
            f.write(f"{name}{version}\n")

def update_requirements(dev: bool = False, freeze: bool = False) -> None:
    """Update requirements files."""
    installed_packages = get_installed_packages()
    
    # Determine which files to update
    target_files = [REQUIREMENTS_TXT]
    if dev:
        target_files.append(REQUIREMENTS_DEV_TXT)
    
    for req_file in target_files:
        # Parse existing requirements
        packages, comments = parse_requirements(req_file)
        
        if freeze:
            # Update all packages to currently installed versions
            for name in list(packages.keys()):
                if name in installed_packages:
                    packages[name] = f"=={installed_packages[name]}"
        else:
            # Only update packages that are already in the file
            for name in list(packages.keys()):
                if name in installed_packages and '==' not in packages[name]:
                    packages[name] = f"=={installed_packages[name]}"
        
        # Write updated requirements
        title = "Development Requirements" if "dev" in str(req_file).lower() else "Core Requirements"
        write_requirements(req_file, packages, comments, title)
        print(f"Updated {req_file.name}")

def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Update project requirements.")
    parser.add_argument(
        "--dev",
        action="store_true",
        help="Update development requirements"
    )
    parser.add_argument(
        "--freeze",
        action="store_true",
        help="Freeze all dependencies to current versions"
    )
    
    args = parser.parse_args()
    
    try:
        update_requirements(dev=args.dev, freeze=args.freeze)
        return 0
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())
